---
title: 互联网协议
author: 王哲峰
date: '2020-05-06'
slug: protocol
categories:
  - web
tags:
  - tool
---

<style>
h1 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}
h2 {
  background-color: #2B90B6;
  background-image: linear-gradient(45deg, #4EC5D4 10%, #146b8c 20%);
  background-size: 100%;
  -webkit-background-clip: text;
  -moz-background-clip: text;
  -webkit-text-fill-color: transparent;
  -moz-text-fill-color: transparent;
}

details {
    border: 1px solid #aaa;
    border-radius: 4px;
    padding: .5em .5em 0;
}

summary {
    font-weight: bold;
    margin: -.5em -.5em 0;
    padding: .5em;
}

details[open] {
    padding: .5em;
}

details[open] summary {
    border-bottom: 1px solid #aaa;
    margin-bottom: .5em;
}
img {
    pointer-events: none;
}
</style>


<details><summary>目录</summary><p>

- [互联网的五层模型](#互联网的五层模型)
- [互联网层与协议](#互联网层与协议)
- [实体层](#实体层)
- [链接层](#链接层)
  - [链接层定义](#链接层定义)
  - [以太网协议](#以太网协议)
  - [MAC 地址](#mac-地址)
  - [广播](#广播)
- [网络层](#网络层)
  - [网络层的由来](#网络层的由来)
  - [IP 协议](#ip-协议)
  - [ARP 协议](#arp-协议)
- [传输层](#传输层)
  - [传输层的由来](#传输层的由来)
  - [UDP 协议](#udp-协议)
  - [TCP 协议](#tcp-协议)
- [应用层](#应用层)
</p></details><p></p>


互联网的核心是一些列协议, 总称为"互联网协议(Internet Protocol
Suite)". 它们对计算机如何连接和组网, 做出了详尽地规定. 理解了这些协议, 就理解了互联网的原理. 


# 互联网的五层模型

互联网的实现, 分成好几层. 每一层都有自己的功能, 就像建筑物一样, 每一层都靠下一层支持. 

用户解除到的知识最上面的一层, 应用层, 根本没有感觉到下面的层. 要理解互联网, 
必须从最下层开始, 自下而上理解每一层的功能. 

如何分层有不同的模型, 有的模型分七层, 有的分四层. 把互联网分成五层比较容易理解. 

![img](images/internet.png)


如上图所示, 最底下的一层叫做
`实体层(Physical Layer)` , 最上面的一层叫做
`应用层(Application Layer)` , 中间的三层(自下而上)分别是
`链接层(Link Layer)` 、`网络层(Network Layer)` 和
`传输层"(Transport Layer)` . 越下面的层, 越靠近硬件; 越上面的层, 越靠近用户. 

# 互联网层与协议

互联网中的每一层都是为了完成一种功能. 为了实现这些功能, 就需要大家遵守共同的规则. 
大家都遵守的规则, 就叫做"协议(protocol)". 

互联网的每一层, 都定义了很多的协议. 这些协议的总称, 就叫做"互联网协议(Internet
Protocol Suite)". 它们是互联网的核心. 

# 实体层

计算机要组网, 第一件事就是先把计算机连起来, 可以用光缆、电缆、双胶线. 无线电波等方式. 

![img](images/physical.png)


这就叫 `实体层(Physical Layer)` , 它就是把计算机连接起来的物理手段. 
它主要规定了网络的一些电气特性, 作用是负责传送 0 和 1 的电信号. 

# 链接层

## 链接层定义

电信号中单纯的 0 和 1 没有任何意义, 必须规定解读方式: 多少个电信号算一组？每个信号位有何意义？
这就是"链接层"的功能, 他在"实体层"的上方, 确定了 0 和 1 的分组方式. 



## 以太网协议

早期的时候, 每家公司都有自己的电信号分组方式. 逐渐地, 
一种叫做 [以太网(Ethernet)](https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91) 的协议占据了主导地位. 

以太网规定, 一组电信号构成一个数据包, 叫做"帧(Frame)". 
每一帧分成两个部分: 标头(Head)和数据(Data). 

![img](images/Frame.png)


"标头"包含数据包的一些说明项, 比如发送者、接受者、数据类型等等; "数据"则是数据包的具体内容. 

"标头"的长度, 固定为18字节. "数据"的长度, 最短为46字节, 最长为1500字节. 
因此, 整个"帧"最短为64字节, 最长为1518字节. 如果数据很长, 就必须分割成多个帧进行发送. 



## MAC 地址

上面提到, 以太网数据包的"标头", 包含了发送者和接受者的信息. 那么, 发送者和接受者是如何标识呢？

以太网规定, 连入网络的所有设备, 都必须具有"网卡"接口. 数据包必须是从一块网卡, 
传送到另一块网卡. 网卡的地址, 就是数据包的发送地址和接收地址, 这叫做MAC地址. 

![img](images/network_card.jpg)


每块网卡出厂的时候, 都有一个全世界独一无二的MAC地址, 长度是48个二进制位, 通常用12个十六进制数表示. 

![img](images/mac_address.png)


前6个十六进制数是厂商编号, 后6个是该厂商的网卡流水号. 有了MAC地址, 就可以定位网卡和数据包的路径了. 

## 广播

定义地址只是第一步, 后面还有更多的步骤. 

首先, 一块网卡怎么会知道另一块网卡的MAC地址？

回答是有一种ARP协议, 可以解决这个问题. 这个留到后面介绍, 这里只需要知道, 
以太网数据包必须知道接收方的MAC地址, 然后才能发送. 

其次, 就算有了MAC地址, 系统怎样才能把数据包准确送到接收方？

回答是以太网采用了一种很"原始"的方式, 它不是把数据包准确送到接收方, 
而是向本网络内所有计算机发送, 让每台计算机自己判断, 是否为接收方. 

![img](images/connect.png)


上图中, 1号计算机向2号计算机发送一个数据包, 同一个子网络的3号、4号、5号计算机都会收到这个包.
它们读取这个包的"标头", 找到接收方的MAC地址, 然后与自身的MAC地址相比较, 如果两者相同, 
就接受这个包, 做进一步处理, 否则就丢弃这个包. 这种发送方式就叫做"广播"(broadcasting). 

有了数据包的定义、网卡的MAC地址、广播的发送方式, "链接层"就可以在多台计算机之间传送数据了. 



# 网络层

## 网络层的由来

以太网协议, 依靠MAC地址发送数据. 理论上, 单单依靠MAC地址, 
上海的网卡就可以找到洛杉矶的网卡了, 技术上是可以实现的. 

但是, 这样做有一个重大的缺点. 以太网采用广播方式发送数据包, 
所有成员人手一"包", 不仅效率低, 而且局限在发送者所在的子网络. 也就是说, 
如果两台计算机不在同一个子网络, 广播是传不过去的. 这种设计是合理的,
 否则互联网上每一台计算机都会收到所有包, 那会引起灾难. 

互联网是无数子网络共同组成的一个巨型网络, 很像想象上海和洛杉矶的电脑会在同一个子网络, 这几乎是不可能的

![img](images/network.png)


因此, 必须找到一种方法, 能够区分哪些MAC地址属于同一个子网络, 哪些不是. 
如果是同一个子网络, 就采用广播方式发送, 否则就采用"路由"方式发送. 
("路由"的意思, 就是指如何向不同的子网络分发数据包, 这是一个很大的主题, 本文不涉及. )
遗憾的是, MAC地址本身无法做到这一点. 它只与厂商有关, 与所处网络无关. 

这就导致了"网络层"的诞生. 它的作用是引进一套新的地址, 
使得我们能够区分不同的计算机是否属于同一个子网络. 
这套地址就叫做"网络地址", 简称"网址". 

于是, "网络层"出现以后, 每台计算机有了两种地址, 一种是MAC地址, 另一种是网络地址. 
两种地址之间没有任何联系, MAC地址是绑定在网卡上的, 网络地址则是管理员分配的, 
它们只是随机组合在一起. 

网络地址帮助我们确定计算机所在的子网络, MAC地址则将数据包送到该子网络中的目标网卡. 
因此, 从逻辑上可以推断, 必定是先处理网络地址, 然后再处理MAC地址. 

## IP 协议

规定网络地址的协议, 叫做IP协议. 它所定义的地址, 就被称为IP地址. 

目前, 广泛采用的是IP协议第四版, 简称IPv4. 这个版本规定, 网络地址由32个二进制位组成. 

![img](images/IPv4.png)


习惯上, 我们用分成四段的十进制数表示IP地址, 从0.0.0.0一直到255.255.255.255. 

互联网上的每一台计算机, 都会分配到一个IP地址. 这个地址分成两个部分, 前一部分代表网络, 
后一部分代表主机. 比如, IP地址172.16.254.1, 这是一个32位的地址, 
假定它的网络部分是前24位(172.16.254), 那么主机部分就是后8位(最后的那个1). 
处于同一个子网络的电脑, 它们IP地址的网络部分必定是相同的, 
也就是说172.16.254.2应该与172.16.254.1处在同一个子网络. 

但是, 问题在于单单从IP地址, 我们无法判断网络部分. 还是以172.16.254.1为例, 
它的网络部分, 到底是前24位, 还是前16位, 甚至前28位, 从IP地址上是看不出来的. 

那么, 怎样才能从IP地址, 判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数"子网掩码"(subnet
mask). 

所谓"子网掩码", 就是表示子网络特征的一个参数. 它在形式上等同于IP地址, 
也是一个32位二进制数字, 它的网络部分全部为1, 主机部分全部为0. 
比如, IP地址172.16.254.1, 如果已知网络部分是前24位, 主机部分是后8位, 
那么子网络掩码就是11111111.11111111.11111111.00000000, 写成十进制就是255.255.255.0. 

知道"子网掩码", 我们就能判断, 任意两个IP地址是否处在同一个子网络. 
方法是将两个IP地址与子网掩码分别进行AND运算(两个数位都为1, 运算结果为1, 否则为0), 
然后比较结果是否相同, 如果是的话, 就表明它们在同一个子网络中, 否则就不是. 

比如, 已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0, 
请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算, 结果都是172.16.254.0, 
因此它们在同一个子网络. 

总结一下, IP协议的作用主要有两个, 一个是为每一台计算机分配IP地址, 
另一个是确定哪些地址在同一个子网络. 



## ARP 协议

关于"网络层", 还有最后一点需要说明. 

因为IP数据包是放在以太网数据包里发送的, 所以我们必须同时知道两个地址, 
一个是对方的MAC地址, 另一个是对方的IP地址. 通常情况下, 
对方的IP地址是已知的(后文会解释), 但是我们不知道它的MAC地址. 

所以, 我们需要一种机制, 能够从IP地址得到MAC地址. 

这里又可以分成两种情况. 第一种情况, 如果两台主机不在同一个子网络, 
那么事实上没有办法得到对方的MAC地址, 只能把数据包传送到两个子网络连接处的"网关"(gateway), 
让网关去处理. 

第二种情况, 如果两台主机在同一个子网络, 那么我们可以用ARP协议, 得到对方的MAC地址. 
ARP协议也是发出一个数据包(包含在以太网数据包中), 其中包含它所要查询主机的IP地址, 
在对方的MAC地址这一栏, 填的是FF:FF:FF:FF:FF:FF, 表示这是一个"广播"地址. 
它所在子网络的每一台主机, 都会收到这个数据包, 从中取出IP地址, 与自身的IP地址进行比较. 
如果两者相同, 都做出回复, 向对方报告自己的MAC地址, 否则就丢弃这个包. 

总之, 有了ARP协议之后, 我们就可以得到同一个子网络内的主机MAC地址, 可以把数据包发送到任意一台主机之上了. 



# 传输层



## 传输层的由来



## UDP 协议



## TCP 协议



# 应用层

